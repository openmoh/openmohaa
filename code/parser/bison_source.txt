%{
/*
* ===========================================================================
* Copyright (C) 2015 the OpenMoHAA team
* 
* This file is part of OpenMoHAA source code.
* 
* OpenMoHAA source code is free software; you can redistribute it
* and/or modify it under the terms of the GNU General Public License as
* published by the Free Software Foundation; either version 2 of the License,
* or (at your option) any later version.
* 
* OpenMoHAA source code is distributed in the hope that it will be
* useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
* GNU General Public License for more details.
* 
* You should have received a copy of the GNU General Public License
* along with OpenMoHAA source code; if not, write to the Free Software
* Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
* ===========================================================================
*
*
* yyParser.*: BISON Parser for MoHScript.
*/

#include "scriptcompiler.h"
#include "./yyParser.hpp"
#include "./yyLexer.h"

// the value was increased because some scripts have a lot of if/else statements
// which ends up with an high depth
#define YYINITDEPTH 500

int yyerror( const char *msg );

extern int prev_yylex;

extern yyparsedata parsedata;

int prev_yylex;
int out_pos;
int success_pos;

#define YYLLOC node_pos(success_pos - yyleng)
#define TOKPOS(pos) node_pos(pos.sourcePos)

%}

%define parse.error verbose
%locations
%define api.location.type { parse_pos_t }

%expect 126

%precedence TOKEN_EOF 0 "end of file"
%precedence TOKEN_EOL

%union {
	stype_t s;
}

%left TOKEN_COMMA

%precedence TOKEN_IF
%right THEN TOKEN_ELSE
%precedence TOKEN_WHILE TOKEN_FOR TOKEN_DO
%precedence <s.val> TOKEN_IDENTIFIER

%precedence TOKEN_LEFT_BRACES TOKEN_RIGHT_BRACES
%right TOKEN_LEFT_BRACKET TOKEN_RIGHT_BRACKET TOKEN_LEFT_SQUARE_BRACKET TOKEN_RIGHT_SQUARE_BRACKET

%right	TOKEN_ASSIGNMENT
		TOKEN_PLUS_EQUALS TOKEN_MINUS_EQUALS TOKEN_MULTIPLY_EQUALS TOKEN_DIVIDE_EQUALS TOKEN_MODULUS_EQUALS
		TOKEN_AND_EQUALS TOKEN_EXCL_OR_EQUALS TOKEN_OR_EQUALS
		TOKEN_SHIFT_LEFT_EQUALS TOKEN_SHIFT_RIGHT_EQUALS
		TOKEN_TERNARY TOKEN_COLON

%left TOKEN_LOGICAL_OR
%left TOKEN_LOGICAL_AND

%left TOKEN_BITWISE_OR
%left TOKEN_BITWISE_EXCL_OR
%left TOKEN_BITWISE_AND

%left TOKEN_EQUALITY TOKEN_INEQUALITY
%left TOKEN_LESS_THAN TOKEN_LESS_THAN_OR_EQUAL TOKEN_GREATER_THAN TOKEN_GREATER_THAN_OR_EQUAL

%left TOKEN_SHIFT_LEFT TOKEN_SHIFT_RIGHT
%left TOKEN_PLUS TOKEN_MINUS
%left TOKEN_MULTIPLY TOKEN_DIVIDE TOKEN_MODULUS

%right TOKEN_NEG TOKEN_NOT TOKEN_COMPLEMENT

%precedence <s.val> TOKEN_STRING
%precedence <s.val> TOKEN_INTEGER
%precedence <s.val> TOKEN_FLOAT

%precedence <s.val> TOKEN_LISTENER
%precedence TOKEN_NIL TOKEN_NULL

%token TOKEN_DOUBLE_COLON
%left TOKEN_SEMICOLON
%right TOKEN_DOLLAR
%left TOKEN_NUMBER

%left TOKEN_INCREMENT TOKEN_DECREMENT TOKEN_PERIOD

%precedence		TOKEN_CATCH TOKEN_TRY
				TOKEN_SWITCH TOKEN_CASE
				TOKEN_BREAK TOKEN_CONTINUE
				TOKEN_SIZE
				TOKEN_END TOKEN_RETURN
				TOKEN_MAKEARRAY TOKEN_ENDARRAY

%type <s.val> event_parameter_list event_parameter_list_need event_parameter
%type <s.val> statement_list statement statement_declaration makearray_statement_list makearray_statement
%type <s.val> compound_statement selection_statement iteration_statement
%type <s.val> expr
%type <s.val> func_prim_expr
%type <s.val> prim_expr
%type <s.val> listener_identifier
%type <s.val> nonident_prim_expr
%type <s.val> func_expr
%type <s.val> const_array_list
%type <s.val> const_array
%type <s.val> identifier_prim
%type <s.val> identifier

%start program
 
%%

program
	: statement_list[list] { parsedata.val = node1(ENUM_statement_list, $list); }
	| line_opt { parsedata.val = node0(ENUM_NOP); }
	;

statement_list
	: statement { $$ = linked_list_end($1); }
	| statement_list statement[stmt] { $$ = append_node($1, $stmt); }
	;

statement
	: line_opt statement_declaration[stmt_decl] line_opt { $$ = $stmt_decl; }
	;

statement_declaration
	: TOKEN_IDENTIFIER event_parameter_list TOKEN_COLON { $$ = node3(ENUM_labeled_statement, $1, $2, TOKPOS(@1)); }
	| TOKEN_CASE prim_expr event_parameter_list TOKEN_COLON { $$ = node3(ENUM_int_labeled_statement, $2, $3, TOKPOS(@1)); }
	| compound_statement
	| selection_statement
	| iteration_statement
	| TOKEN_TRY compound_statement[C1] TOKEN_CATCH compound_statement[C2] { $$ = node3(ENUM_try, $C1, $C2, TOKPOS(@1)); }
	| TOKEN_BREAK { $$ = node1(ENUM_break, TOKPOS(@1)); }
	| TOKEN_CONTINUE { $$ = node1(ENUM_continue, TOKPOS(@1)); }
	| TOKEN_IDENTIFIER event_parameter_list { $$ = node3(ENUM_cmd_event_statement, $1, $2, TOKPOS(@1)); }
	| nonident_prim_expr TOKEN_IDENTIFIER event_parameter_list { $$ = node4(ENUM_method_event_statement, $1, $2, $3, TOKPOS(@2)); }
	| nonident_prim_expr TOKEN_ASSIGNMENT expr { $$ = node3(ENUM_assignment_statement, $1, $3, TOKPOS(@2)); }
	| nonident_prim_expr TOKEN_PLUS_EQUALS expr { $$ = node3(ENUM_assignment_statement, $1, node4(ENUM_func2_expr, node1b(OP_BIN_PLUS), $1, $3, TOKPOS(@2)), TOKPOS(@2)); }
	| nonident_prim_expr TOKEN_MINUS_EQUALS expr { $$ = node3(ENUM_assignment_statement, $1, node4(ENUM_func2_expr, node1b(OP_BIN_MINUS), $1, $3, TOKPOS(@2)), TOKPOS(@2)); }
	| nonident_prim_expr TOKEN_MULTIPLY_EQUALS expr { $$ = node3(ENUM_assignment_statement, $1, node4(ENUM_func2_expr, node1b(OP_BIN_MULTIPLY), $1, $3, TOKPOS(@2)), TOKPOS(@2)); }
	| nonident_prim_expr TOKEN_DIVIDE_EQUALS expr { $$ = node3(ENUM_assignment_statement, $1, node4(ENUM_func2_expr, node1b(OP_BIN_DIVIDE), $1, $3, TOKPOS(@2)), TOKPOS(@2)); }
	| nonident_prim_expr TOKEN_MODULUS_EQUALS expr { $$ = node3(ENUM_assignment_statement, $1, node4(ENUM_func2_expr, node1b(OP_BIN_PERCENTAGE), $1, $3, TOKPOS(@2)), TOKPOS(@2)); }
	| nonident_prim_expr TOKEN_AND_EQUALS expr { $$ = node3(ENUM_assignment_statement, $1, node4(ENUM_func2_expr, node1b(OP_BIN_BITWISE_AND), $1, $3, TOKPOS(@2)), TOKPOS(@2)); }
	| nonident_prim_expr TOKEN_EXCL_OR_EQUALS expr { $$ = node3(ENUM_assignment_statement, $1, node4(ENUM_func2_expr, node1b(OP_BIN_BITWISE_EXCL_OR), $1, $3, TOKPOS(@2)), TOKPOS(@2)); }
	| nonident_prim_expr TOKEN_OR_EQUALS expr { $$ = node3(ENUM_assignment_statement, $1, node4(ENUM_func2_expr, node1b(OP_BIN_BITWISE_OR), $1, $3, TOKPOS(@2)), TOKPOS(@2)); }
	| nonident_prim_expr TOKEN_SHIFT_LEFT_EQUALS expr { $$ = node3(ENUM_assignment_statement, $1, node4(ENUM_func2_expr, node1b(OP_BIN_SHIFT_LEFT), $1, $3, TOKPOS(@2)), TOKPOS(@2)); }
	| nonident_prim_expr TOKEN_SHIFT_RIGHT_EQUALS expr { $$ = node3(ENUM_assignment_statement, $1, node4(ENUM_func2_expr, node1b(OP_BIN_SHIFT_RIGHT), $1, $3, TOKPOS(@2)), TOKPOS(@2)); }
	| nonident_prim_expr TOKEN_INCREMENT { $$ = node3(ENUM_assignment_statement, $1, node3(ENUM_func1_expr, node1b(OP_UN_INC), $1, TOKPOS(@2)), TOKPOS(@2)); }
	| nonident_prim_expr TOKEN_DECREMENT { $$ = node3(ENUM_assignment_statement, $1, node3(ENUM_func1_expr, node1b(OP_UN_DEC), $1, TOKPOS(@2)), TOKPOS(@2)); }
	| TOKEN_SEMICOLON { $$ = node0(ENUM_NOP); }
	//| TOKEN_IDENTIFIER TOKEN_DOUBLE_COLON TOKEN_IDENTIFIER event_parameter_list { $$ = node3( ENUM_method_event_statement, node_string( parsetree_string( str( $1.stringValue ) + "::" + $3.stringValue ) ), node1( ENUM_NOP, $4 ), TOKPOS(@1) ); }
	//| nonident_prim_expr TOKEN_IDENTIFIER TOKEN_DOUBLE_COLON TOKEN_IDENTIFIER event_parameter_list { $$ = node4( ENUM_method_event_statement, $1, node_string( parsetree_string( str( $2.stringValue ) + "::" + $4.stringValue ) ), node1( ENUM_NOP, $5 ), TOKPOS(@2) ); }
	;

compound_statement
	: TOKEN_LEFT_BRACES statement_list TOKEN_RIGHT_BRACES { $$ = node1(ENUM_statement_list, $2); }
	| TOKEN_LEFT_BRACES line_opt TOKEN_RIGHT_BRACES { $$ = node0(ENUM_NOP); }
	| line_opt compound_statement[comp_stmt] line_opt { $$ = $comp_stmt; }
	;

selection_statement
	: TOKEN_IF prim_expr[exp] statement[stmt] %prec THEN { $$ = node3(ENUM_if_statement, $exp, $stmt, TOKPOS(@1)); }
	| TOKEN_IF prim_expr[exp] statement[if_stmt] TOKEN_ELSE statement[else_stmt] { $$ = node4(ENUM_if_else_statement, $exp, $if_stmt, $else_stmt, TOKPOS(@1)); }
	| TOKEN_SWITCH prim_expr[exp] compound_statement[comp_stmt] { $$ = node3(ENUM_switch, $exp, $comp_stmt, TOKPOS(@1)); }
	;

iteration_statement
	: TOKEN_WHILE prim_expr[exp] statement[stmt]{ $$ = node4(ENUM_while_statement, $exp, $stmt, node0(ENUM_NOP), TOKPOS(@1)); }
	| TOKEN_FOR TOKEN_LEFT_BRACKET statement[init_stmt] TOKEN_SEMICOLON expr[exp] TOKEN_SEMICOLON statement_list[inc_stmt] TOKEN_RIGHT_BRACKET statement[stmt]
	{
		sval_t while_stmt = node4(ENUM_while_statement, $exp, $stmt, node1(ENUM_statement_list, $inc_stmt), TOKPOS(@1));
		$$ = node1(ENUM_statement_list, append_node(linked_list_end($init_stmt), while_stmt));
	}
	| TOKEN_FOR TOKEN_LEFT_BRACKET TOKEN_SEMICOLON expr[exp] TOKEN_SEMICOLON statement_list[inc_stmt] TOKEN_RIGHT_BRACKET statement[stmt]
	{
		$$ = node4(ENUM_while_statement, $exp, $stmt, node1(ENUM_statement_list, $inc_stmt), TOKPOS(@1));
	}
	| TOKEN_DO statement[stmt] TOKEN_WHILE prim_expr[exp]{ $$ = node3(ENUM_do, $stmt, $exp, TOKPOS(@1)); }
	;

expr:
	expr TOKEN_LOGICAL_AND expr { $$ = node3( ENUM_logical_and, $1, $3, TOKPOS(@2) ); }
	| expr TOKEN_LOGICAL_OR expr { $$ = node3( ENUM_logical_or, $1, $3, TOKPOS(@2) ); }
	| expr TOKEN_BITWISE_AND expr { $$ = node4( ENUM_func2_expr, node1b( OP_BIN_BITWISE_AND ), $1, $3, TOKPOS(@2) ); }
	| expr TOKEN_BITWISE_OR expr { $$ = node4( ENUM_func2_expr, node1b( OP_BIN_BITWISE_OR ), $1, $3, TOKPOS(@2) ); }
	| expr TOKEN_BITWISE_EXCL_OR expr { $$ = node4( ENUM_func2_expr, node1b( OP_BIN_BITWISE_EXCL_OR ), $1, $3, TOKPOS(@2) ); }
	| expr TOKEN_EQUALITY expr { $$ = node4( ENUM_func2_expr, node1b( OP_BIN_EQUALITY ), $1, $3, TOKPOS(@2) ); }
	| expr TOKEN_INEQUALITY expr { $$ = node4( ENUM_func2_expr, node1b( OP_BIN_INEQUALITY ), $1, $3, TOKPOS(@2) ); }
	| expr TOKEN_LESS_THAN expr { $$ = node4( ENUM_func2_expr, node1b( OP_BIN_LESS_THAN ), $1, $3, TOKPOS(@2) ); }
	| expr TOKEN_GREATER_THAN expr { $$ = node4( ENUM_func2_expr, node1b( OP_BIN_GREATER_THAN ), $1, $3, TOKPOS(@2) ); }
	| expr TOKEN_LESS_THAN_OR_EQUAL expr { $$ = node4( ENUM_func2_expr, node1b( OP_BIN_LESS_THAN_OR_EQUAL ), $1, $3, TOKPOS(@2) ); }
	| expr TOKEN_GREATER_THAN_OR_EQUAL expr { $$ = node4( ENUM_func2_expr, node1b( OP_BIN_GREATER_THAN_OR_EQUAL ), $1, $3, TOKPOS(@2) ); }
	| expr TOKEN_PLUS expr { $$ = node4( ENUM_func2_expr, node1b( OP_BIN_PLUS ), $1, $3, TOKPOS(@2) ); }
	| expr TOKEN_MINUS expr { $$ = node4( ENUM_func2_expr, node1b( OP_BIN_MINUS ), $1, $3, TOKPOS(@2) ); }
	| expr TOKEN_MULTIPLY expr { $$ = node4( ENUM_func2_expr, node1b( OP_BIN_MULTIPLY ), $1, $3, TOKPOS(@2) ); }
	| expr TOKEN_DIVIDE expr { $$ = node4( ENUM_func2_expr, node1b( OP_BIN_DIVIDE ), $1, $3, TOKPOS(@2) ); }
	| expr TOKEN_MODULUS expr { $$ = node4( ENUM_func2_expr, node1b( OP_BIN_PERCENTAGE ), $1, $3, TOKPOS(@2) ); }
	| expr TOKEN_SHIFT_LEFT expr { $$ = node4( ENUM_func2_expr, node1b( OP_BIN_SHIFT_LEFT ), $1, $3, TOKPOS(@2) ); }
	| expr TOKEN_SHIFT_RIGHT expr { $$ = node4( ENUM_func2_expr, node1b( OP_BIN_SHIFT_RIGHT ), $1, $3, TOKPOS(@2) ); }
	| expr TOKEN_TERNARY expr TOKEN_COLON expr { $$ = node4( ENUM_if_else_statement, $1, $3, $5, TOKPOS(@2) ); }
	| TOKEN_EOL expr[exp] { $$ = $exp; }
	| nonident_prim_expr
	| func_prim_expr
	| TOKEN_IDENTIFIER { $$ = node2(ENUM_string, $1, TOKPOS(@1)); }
	;

func_prim_expr:
	TOKEN_IDENTIFIER event_parameter_list_need { $$ = node3(ENUM_cmd_event_expr, $1, $2, TOKPOS(@1)); }
	| nonident_prim_expr TOKEN_IDENTIFIER event_parameter_list { $$ = node4(ENUM_method_event_expr, $1, $2, $3, TOKPOS(@2)); }
	| func_expr func_prim_expr { $$ = node3(ENUM_func1_expr, $1, $2, TOKPOS(@1)); }
	| TOKEN_NOT func_prim_expr { $$ = node2(ENUM_bool_not, $2, TOKPOS(@1)); }
	| TOKEN_IDENTIFIER TOKEN_DOUBLE_COLON const_array_list
		{
			$$ = node3(ENUM_const_array_expr, node2(ENUM_string, $1, TOKPOS(@1)), $3, TOKPOS(@2));
		}
	| nonident_prim_expr TOKEN_DOUBLE_COLON const_array_list
		{
			$$ = node3(ENUM_const_array_expr, $1, $3, TOKPOS(@2));
		}
	| TOKEN_MAKEARRAY makearray_statement_list[stmt] TOKEN_ENDARRAY
		{
			$$ = node2(ENUM_makearray, $stmt, TOKPOS(@1));
		}
	;

event_parameter_list
	: { $$ = sval_u{}; $$.node = NULL; }
	| event_parameter { $$ = $1; }
	;

event_parameter_list_need
	: event_parameter { $$ = $1; }
	;

event_parameter
	: prim_expr { $$ = linked_list_end($1); }
	| event_parameter prim_expr { $$ = append_node($1, $2); }
	;

const_array_list
	: const_array { $$ = linked_list_end($1); }
	| const_array_list TOKEN_DOUBLE_COLON const_array { $$ = append_node($1, $3); }
	;

const_array
	: nonident_prim_expr
	| identifier_prim { $$ = node2(ENUM_string, $1, TOKPOS(@1)); }
	;

prim_expr
	: nonident_prim_expr
	| identifier_prim { $$ = node2(ENUM_string, $1, TOKPOS(@1)); }
	| prim_expr TOKEN_DOUBLE_COLON const_array_list { $$ = node3(ENUM_const_array_expr, $1, $3, TOKPOS(@2)); }
	;

identifier_prim:
	TOKEN_IDENTIFIER { $$ = $1; @$ = @1; }
	;

identifier
	: TOKEN_IDENTIFIER { $$ = $1; @$ = @1; }
	| TOKEN_STRING { $$ = $1; @$ = @1; }
	;

listener_identifier
	: identifier_prim { $$ = node2(ENUM_string, $1, TOKPOS(@1)); }
	| TOKEN_LEFT_BRACKET expr TOKEN_RIGHT_BRACKET { $$ = $2; }
	;

nonident_prim_expr
	: TOKEN_DOLLAR listener_identifier { $$ = node3(ENUM_func1_expr, node1b(OP_UN_TARGETNAME), $2, TOKPOS(@1)); }
	| nonident_prim_expr TOKEN_PERIOD identifier { $$ = node3(ENUM_field, $1, $3, TOKPOS(@3)); }
	| nonident_prim_expr TOKEN_PERIOD TOKEN_SIZE { $$ = node3(ENUM_func1_expr, node1b(OP_UN_SIZE), $1, TOKPOS(@3)); }
	| nonident_prim_expr TOKEN_LEFT_SQUARE_BRACKET expr TOKEN_RIGHT_SQUARE_BRACKET { $$ = node3(ENUM_array_expr, $1, $3, TOKPOS(@2)); }
	| TOKEN_STRING { $$ = node2(ENUM_string, $1, TOKPOS(@1)); }
	| TOKEN_INTEGER { $$ = node2(ENUM_integer, $1, TOKPOS(@1)); }
	| TOKEN_FLOAT { $$ = node2(ENUM_float, $1, TOKPOS(@1)); }
	| TOKEN_LEFT_BRACKET expr[exp1] expr[exp2] expr[exp3] TOKEN_RIGHT_BRACKET { $$ = node4(ENUM_vector, $exp1, $exp2, $exp3, TOKPOS(@1)); }
	| TOKEN_LISTENER { $$ = node2(ENUM_listener, $1, TOKPOS(@1)); }
	| TOKEN_LEFT_BRACKET expr TOKEN_RIGHT_BRACKET { $$ = $2; }
	| TOKEN_LEFT_BRACKET expr TOKEN_EOL TOKEN_RIGHT_BRACKET { $$ = $2; }
	| func_expr nonident_prim_expr { $$ = node3(ENUM_func1_expr, $1, $2, TOKPOS(@1)); }
	| TOKEN_NOT nonident_prim_expr { $$ = node2(ENUM_bool_not, $2, TOKPOS(@1)); }
	| TOKEN_NULL { $$ = node1(ENUM_NULL, TOKPOS(@1)); }
	| TOKEN_NIL { $$ = node1(ENUM_NIL, TOKPOS(@1)); }
	;

func_expr
	: TOKEN_NEG { $$ = node1b(OP_UN_MINUS); }
	| TOKEN_COMPLEMENT { $$ = node1b(OP_UN_COMPLEMENT); }
	;

makearray_statement_list:
	{ $$ = node0(ENUM_NOP); }
	| makearray_statement_list[list] makearray_statement[ma_stmt] TOKEN_EOL { $$ = append_node($list, node2(ENUM_makearray, $ma_stmt, TOKPOS(@ma_stmt))); }
	| makearray_statement[ma_stmt] TOKEN_EOL { $$ = linked_list_end(node2(ENUM_makearray, $ma_stmt, TOKPOS(@ma_stmt))); }
	| TOKEN_EOL makearray_statement_list { $$ = $2; @$ = @2; }
	;

makearray_statement:
	prim_expr { $$ = linked_list_end( $1 ); }
	| makearray_statement prim_expr { $$ = append_node( $1, $2 ); }
	;

line_opt
	: {}
	| TOKEN_EOL
	;
 
%%
